{
  "api/index.html": {
    "href": "api/index.html",
    "title": "Documentation to code of Save System package",
    "keywords": "Documentation to code of Save System package Base classes of the save system: DataManager - saving and loading your objects SaveSystemCore - the main class of the Save System for all types of saving ObjectHandler and AsyncObjectHandler - more convenient classes for saving and loading of the objects ObjectHandlersFactory - use it to create the handlers CheckPointsFactory - use it to create a checkpoints at runtime UnityWriter - writing your data UnityReader - reading your data Dependencies: UniTask - adapts async\\await to Unity"
  },
  "api/SaveSystem.AsyncMode.html": {
    "href": "api/SaveSystem.AsyncMode.html",
    "title": "Enum AsyncMode",
    "keywords": "Enum AsyncMode See manual Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public enum AsyncMode"
  },
  "api/SaveSystem.CheckPoints.CheckPoint.html": {
    "href": "api/SaveSystem.CheckPoints.CheckPoint.html",
    "title": "Class CheckPoint",
    "keywords": "Class CheckPoint Inheritance object Object Component Behaviour MonoBehaviour CheckPointBase CheckPoint Namespace: SaveSystem.CheckPoints Assembly: SaveSystem.dll Syntax [AddComponentMenu(\"Scripts/Check Point\")] [RequireComponent(typeof(SphereCollider))] public class CheckPoint : CheckPointBase"
  },
  "api/SaveSystem.CheckPoints.CheckPoint2D.html": {
    "href": "api/SaveSystem.CheckPoints.CheckPoint2D.html",
    "title": "Class CheckPoint2D",
    "keywords": "Class CheckPoint2D Inheritance object Object Component Behaviour MonoBehaviour CheckPointBase CheckPoint2D Namespace: SaveSystem.CheckPoints Assembly: SaveSystem.dll Syntax [AddComponentMenu(\"Scripts/Check Point 2D\")] [RequireComponent(typeof(CircleCollider2D))] public class CheckPoint2D : CheckPointBase"
  },
  "api/SaveSystem.CheckPoints.CheckPointBase.html": {
    "href": "api/SaveSystem.CheckPoints.CheckPointBase.html",
    "title": "Class CheckPointBase",
    "keywords": "Class CheckPointBase Inheritance object Object Component Behaviour MonoBehaviour CheckPointBase CheckPoint CheckPoint2D Namespace: SaveSystem.CheckPoints Assembly: SaveSystem.dll Syntax [Icon(\"Packages/com.dducode.save-system/Editor/Icons/checkpoint_icon.png\")] [DisallowMultipleComponent] public abstract class CheckPointBase : MonoBehaviour"
  },
  "api/SaveSystem.CheckPoints.CheckPointsFactory.html": {
    "href": "api/SaveSystem.CheckPoints.CheckPointsFactory.html",
    "title": "Class CheckPointsFactory",
    "keywords": "Class CheckPointsFactory You can create checkpoints at runtime by using this class Inheritance object CheckPointsFactory Namespace: SaveSystem.CheckPoints Assembly: SaveSystem.dll Syntax public static class CheckPointsFactory Methods CreateCheckPoint(Vector3, float) Creates a 3D checkpoint with sphere collider public static CheckPoint CreateCheckPoint(Vector3 position, float radius = 0.5) Parameters position Vector3 3D Position at which the checkpoint will be created radius float Radius of trigger Returns CheckPoint CreateCheckPoint2D(Vector2, float) Creates a 2D checkpoint with circle collider 2D public static CheckPoint2D CreateCheckPoint2D(Vector2 position, float radius = 0.5) Parameters position Vector2 2D Position at which the checkpoint will be created radius float Radius of trigger Returns CheckPoint2D"
  },
  "api/SaveSystem.CheckPoints.html": {
    "href": "api/SaveSystem.CheckPoints.html",
    "title": "Namespace SaveSystem.CheckPoints",
    "keywords": "Namespace SaveSystem.CheckPoints Classes CheckPoint CheckPoint2D CheckPointBase CheckPointsFactory You can create checkpoints at runtime by using this class"
  },
  "api/SaveSystem.Core.html": {
    "href": "api/SaveSystem.Core.html",
    "title": "Namespace SaveSystem.Core",
    "keywords": "Namespace SaveSystem.Core Classes SaveSystemCore The Core of the Save System. It accepts object handlers and persistent objects and starts saving in three main modes - autosave, quick-save and save at checkpoint. Also it starts the saving when the player exit the game SaveSystemSettings Enums SaveEvents Defines save events that can be managed by external code SaveType Contains information about the type of saving"
  },
  "api/SaveSystem.Core.SaveEvents.html": {
    "href": "api/SaveSystem.Core.SaveEvents.html",
    "title": "Enum SaveEvents",
    "keywords": "Enum SaveEvents Defines save events that can be managed by external code Namespace: SaveSystem.Core Assembly: SaveSystem.dll Syntax [Flags] public enum SaveEvents Remarks You can combine events with each other Examples EnabledEvents = SaveEvents.AutoSave | SaveEvents.OnFocusChanged"
  },
  "api/SaveSystem.Core.SaveSystemCore.html": {
    "href": "api/SaveSystem.Core.SaveSystemCore.html",
    "title": "Class SaveSystemCore",
    "keywords": "Class SaveSystemCore The Core of the Save System. It accepts object handlers and persistent objects and starts saving in three main modes - autosave, quick-save and save at checkpoint. Also it starts the saving when the player exit the game Inheritance object SaveSystemCore Namespace: SaveSystem.Core Assembly: SaveSystem.dll Syntax public static class SaveSystemCore Properties DebugEnabled Enables logs public static bool DebugEnabled { get; set; } Property Value bool Remarks It configures only simple logs, other logs (warnings and errors) will be written to console anyway. DestroyCheckPoints Determines whether checkpoints will be destroyed after saving public static bool DestroyCheckPoints { get; set; } Property Value bool If true, triggered checkpoint will be deleted from scene after saving EnabledSaveEvents It's used to manage autosave loop, save on focus changed, on low memory and on quitting the game public static SaveEvents EnabledSaveEvents { get; set; } Property Value SaveEvents See Also SaveEvents IsParallel Configure it to set parallel saving handlers public static bool IsParallel { get; set; } Property Value bool PlayerTag Player tag is used to filtering messages from triggered checkpoints public static string PlayerTag { get; set; } Property Value string Tag of the player object SavePeriod It's used into autosave loop to determine saving frequency public static float SavePeriod { get; set; } Property Value float Saving period in seconds Remarks If it equals 0, saving will be executed at every frame Methods BindKey(KeyCode) Binds any key with quick save public static void BindKey(KeyCode keyCode) Parameters keyCode KeyCode ConfigureParameters(SaveEvents, bool, bool, bool, string, float) Configures all the Core parameters public static void ConfigureParameters(SaveEvents enabledSaveEvents, bool isParallel, bool debugEnabled, bool destroyCheckPoints, string playerTag, float savePeriod = 0) Parameters enabledSaveEvents SaveEvents isParallel bool debugEnabled bool DebugEnabled destroyCheckPoints bool DestroyCheckPoints playerTag string PlayerTag savePeriod float SavePeriod Remarks You can skip it if you have configured the settings in the editor ObserveProgress(IProgress<float>) Pass IProgress object to observe async saving progress when it'll be started public static void ObserveProgress(IProgress<float> progress) Parameters progress IProgress<float> Remarks The Core will report progress only during async save QuickSave() You can call it when any event was happened public static void QuickSave() RegisterAsyncObjectHandler(IAsyncObjectHandler) Registers an async handler to automatic save, quick-save, save at checkpoit and at save on exit public static void RegisterAsyncObjectHandler(IAsyncObjectHandler handler) Parameters handler IAsyncObjectHandler RegisterObjectHandler(IObjectHandler) Registers a handler to automatic save, quick-save, save at checkpoit and at save on exit public static void RegisterObjectHandler(IObjectHandler handler) Parameters handler IObjectHandler SaveAndQuit() Call this to manually save handlers before quitting the application public static UniTask SaveAndQuit() Returns UniTask Remarks This will immediately exit the game after saving. You should make sure that you don't need to do anything else before calling it Events OnSaveEnd Event that is called after saving public static event Action<SaveType> OnSaveEnd Event Type Action<SaveType> Listeners that will be called when core will finish saving. Listeners must accept SaveType enumeration OnSaveStart Event that is called before saving. It can be useful when you use async saving public static event Action<SaveType> OnSaveStart Event Type Action<SaveType> Listeners that will be called when core will start saving. Listeners must accept SaveType enumeration"
  },
  "api/SaveSystem.Core.SaveSystemSettings.html": {
    "href": "api/SaveSystem.Core.SaveSystemSettings.html",
    "title": "Class SaveSystemSettings",
    "keywords": "Class SaveSystemSettings Inheritance object Object ScriptableObject SaveSystemSettings Namespace: SaveSystem.Core Assembly: SaveSystem.dll Syntax public class SaveSystemSettings : ScriptableObject Fields debugEnabled [Tooltip(\"Enables logs\\nIt configures only simple logs, other logs (warnings and errors) will be written to console anyway.\")] public bool debugEnabled Field Value bool destroyCheckPoints [Tooltip(\"Determines whether checkpoints will be destroyed after saving\")] public bool destroyCheckPoints Field Value bool enabledSaveEvents public SaveEvents enabledSaveEvents Field Value SaveEvents isParallel [Tooltip(\"Configure it to set parallel saving handlers\\nYou must ensure that your objects are thread safe\")] public bool isParallel Field Value bool playerTag public string playerTag Field Value string registerImmediately [Tooltip(\"Configure it to automatically register handlers in the Save System Core after creation\")] public bool registerImmediately Field Value bool savePeriod [Min(0)] [Tooltip(\"It's used into autosave loop to determine saving frequency\\nIf it equals 0, saving will be executed at every frame\")] public float savePeriod Field Value float"
  },
  "api/SaveSystem.Core.SaveType.html": {
    "href": "api/SaveSystem.Core.SaveType.html",
    "title": "Enum SaveType",
    "keywords": "Enum SaveType Contains information about the type of saving Namespace: SaveSystem.Core Assembly: SaveSystem.dll Syntax public enum SaveType"
  },
  "api/SaveSystem.DataBuffer.html": {
    "href": "api/SaveSystem.DataBuffer.html",
    "title": "Struct DataBuffer",
    "keywords": "Struct DataBuffer The buffer for writing and reading data from buffered objects Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public struct DataBuffer Fields boolean public bool boolean Field Value bool bytes public ReadOnlyMemory<byte> bytes Field Value ReadOnlyMemory<byte> charBuffer public ReadOnlyMemory<char> charBuffer Field Value ReadOnlyMemory<char> color public Color color Field Value Color color32 public Color32 color32 Field Value Color32 colors public ReadOnlyMemory<Color> colors Field Value ReadOnlyMemory<Color> colors32 public ReadOnlyMemory<Color32> colors32 Field Value ReadOnlyMemory<Color32> doubleBuffer public ReadOnlyMemory<double> doubleBuffer Field Value ReadOnlyMemory<double> floatBuffer public ReadOnlyMemory<float> floatBuffer Field Value ReadOnlyMemory<float> intBuffer public ReadOnlyMemory<int> intBuffer Field Value ReadOnlyMemory<int> longBuffer public ReadOnlyMemory<long> longBuffer Field Value ReadOnlyMemory<long> matrices public ReadOnlyMemory<Matrix4x4> matrices Field Value ReadOnlyMemory<Matrix4x4> matrix public Matrix4x4 matrix Field Value Matrix4x4 meshData public MeshData meshData Field Value MeshData quaternion public Quaternion quaternion Field Value Quaternion shorts public ReadOnlyMemory<short> shorts Field Value ReadOnlyMemory<short> stringBuffer public ReadOnlyMemory<string> stringBuffer Field Value ReadOnlyMemory<string> vector2 public Vector2 vector2 Field Value Vector2 vector2Buffer public ReadOnlyMemory<Vector2> vector2Buffer Field Value ReadOnlyMemory<Vector2> vector3 public Vector3 vector3 Field Value Vector3 vector3Buffer public ReadOnlyMemory<Vector3> vector3Buffer Field Value ReadOnlyMemory<Vector3> vector4 public Vector4 vector4 Field Value Vector4 vector4Buffer public ReadOnlyMemory<Vector4> vector4Buffer Field Value ReadOnlyMemory<Vector4>"
  },
  "api/SaveSystem.DataManager.Advanced.html": {
    "href": "api/SaveSystem.DataManager.Advanced.html",
    "title": "Class DataManager.Advanced",
    "keywords": "Class DataManager.Advanced Contains the methods for advanced objects handling See manual Inheritance object DataManager.Advanced Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public static class DataManager.Advanced Methods LoadObjectAsync(string, IPersistentObjectAsync, CancellationTokenSource, Action) Load one object async [Obsolete(\"The method is obsolete and may be removed later. Use the AdvancedDataHandler instead this\")] public static UniTask<bool> LoadObjectAsync(string filePath, IPersistentObjectAsync obj, CancellationTokenSource source = null, Action onComplete = null) Parameters filePath string the file whereof the object data will be load obj IPersistentObjectAsync the object which will be load source CancellationTokenSource onComplete Action Returns UniTask<bool> Returns true if there is saved data, otherwise false Exceptions OperationCanceledException throws when loading is canceled LoadObjectsAsync(string, IPersistentObjectAsync[], IProgress<float>, CancellationTokenSource, Action) Load many objects async [Obsolete(\"The method is obsolete and may be removed later. Use the AdvancedDataHandler instead this\")] public static UniTask<bool> LoadObjectsAsync(string filePath, IPersistentObjectAsync[] objects, IProgress<float> progress = null, CancellationTokenSource source = null, Action onComplete = null) Parameters filePath string the file whereof the object data will be load objects IPersistentObjectAsync[] the objects which will be load progress IProgress<float> source CancellationTokenSource onComplete Action Returns UniTask<bool> Returns true if there is saved data, otherwise false Exceptions OperationCanceledException throws when loading is canceled SaveObjectAsync(string, IPersistentObjectAsync, CancellationTokenSource, Action) Save one object async [Obsolete(\"The method is obsolete and may be removed later. Use the AdvancedDataHandler instead this\")] public static UniTask SaveObjectAsync(string filePath, IPersistentObjectAsync obj, CancellationTokenSource source = null, Action onComplete = null) Parameters filePath string the file where the object data will be saved obj IPersistentObjectAsync the object which will be saved source CancellationTokenSource onComplete Action Returns UniTask Exceptions OperationCanceledException throws when saving is canceled SaveObjectsAsync(string, IPersistentObjectAsync[], IProgress<float>, CancellationTokenSource, Action) Save many objects async [Obsolete(\"The method is obsolete and may be removed later. Use the AdvancedDataHandler instead this\")] public static UniTask SaveObjectsAsync(string filePath, IPersistentObjectAsync[] objects, IProgress<float> progress = null, CancellationTokenSource source = null, Action onComplete = null) Parameters filePath string the file where the object data will be saved objects IPersistentObjectAsync[] the objects which will be saved progress IProgress<float> source CancellationTokenSource onComplete Action Returns UniTask Exceptions OperationCanceledException throws when saving is canceled"
  },
  "api/SaveSystem.DataManager.html": {
    "href": "api/SaveSystem.DataManager.html",
    "title": "Class DataManager",
    "keywords": "Class DataManager Main class for handling data Inheritance object DataManager Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public static class DataManager Methods LoadObject<T>(string, T) Load one object public static bool LoadObject<T>(string filePath, T obj) where T : IPersistentObject Parameters filePath string the file whereof the object data will be load obj T the object which will be load Returns bool Returns true if there is saved data, otherwise false Type Parameters T LoadObjectAsync(string, IPersistentObject, AsyncMode, CancellationTokenSource, Action) Load one object async [Obsolete(\"It's the obsolete method and it may be removed later. Use methods of the HandlersProvider class instead this.\")] public static UniTask<bool> LoadObjectAsync(string filePath, IPersistentObject obj, AsyncMode asyncMode, CancellationTokenSource source = null, Action onComplete = null) Parameters filePath string the file whereof the object data will be load obj IPersistentObject the object which will be load asyncMode AsyncMode source CancellationTokenSource onComplete Action Returns UniTask<bool> Returns true if there is saved data, otherwise false Exceptions OperationCanceledException throws when loading is canceled LoadObjects<T>(string, ICollection<T>) Load many objects public static bool LoadObjects<T>(string filePath, ICollection<T> objects) where T : IPersistentObject Parameters filePath string the file whereof the object data will be load objects ICollection<T> the objects which will be load Returns bool Returns true if there is saved data, otherwise false Type Parameters T LoadObjectsAsync(string, IPersistentObject[], AsyncMode, IProgress<float>, CancellationTokenSource, Action) Load many objects async [Obsolete(\"It's the obsolete method and it may be removed later. Use methods of the HandlersProvider class instead this.\")] public static UniTask<bool> LoadObjectsAsync(string filePath, IPersistentObject[] objects, AsyncMode asyncMode, IProgress<float> progress = null, CancellationTokenSource source = null, Action onComplete = null) Parameters filePath string the file whereof the object data will be load objects IPersistentObject[] the objects which will be load asyncMode AsyncMode progress IProgress<float> source CancellationTokenSource onComplete Action Returns UniTask<bool> Returns true if there is saved data, otherwise false Exceptions OperationCanceledException throws when loading is canceled SaveObject<T>(string, T) Save one object public static void SaveObject<T>(string filePath, T obj) where T : IPersistentObject Parameters filePath string the file where the object data will be saved obj T the object which will be saved Type Parameters T SaveObjectAsync(string, IPersistentObject, AsyncMode, CancellationTokenSource, Action) Save one object async [Obsolete(\"It's the obsolete method and it may be removed later. Use methods of the HandlersProvider class instead this.\")] public static UniTask SaveObjectAsync(string filePath, IPersistentObject obj, AsyncMode asyncMode, CancellationTokenSource source = null, Action onComplete = null) Parameters filePath string the file where the object data will be saved obj IPersistentObject the object which will be saved asyncMode AsyncMode source CancellationTokenSource onComplete Action Returns UniTask Exceptions OperationCanceledException throws when saving is canceled SaveObjects<T>(string, ICollection<T>) Save many objects public static void SaveObjects<T>(string filePath, ICollection<T> objects) where T : IPersistentObject Parameters filePath string the file where the object data will be saved objects ICollection<T> the objects which will be saved Type Parameters T SaveObjectsAsync(string, IPersistentObject[], AsyncMode, IProgress<float>, CancellationTokenSource, Action) Save many objects async [Obsolete(\"It's the obsolete method and it may be removed later. Use methods of the HandlersProvider class instead this.\")] public static UniTask SaveObjectsAsync(string filePath, IPersistentObject[] objects, AsyncMode asyncMode, IProgress<float> progress = null, CancellationTokenSource source = null, Action onComplete = null) Parameters filePath string the file where the object data will be saved objects IPersistentObject[] the objects which will be saved asyncMode AsyncMode progress IProgress<float> source CancellationTokenSource onComplete Action Returns UniTask Exceptions OperationCanceledException throws when saving is canceled"
  },
  "api/SaveSystem.Extensions.BinaryHandlersExtensions.html": {
    "href": "api/SaveSystem.Extensions.BinaryHandlersExtensions.html",
    "title": "Class BinaryHandlersExtensions",
    "keywords": "Class BinaryHandlersExtensions Inheritance object BinaryHandlersExtensions Namespace: SaveSystem.Extensions Assembly: SaveSystem.dll Syntax public static class BinaryHandlersExtensions Methods ExpandToUnityReader(BinaryReader) public static UnityReader ExpandToUnityReader(this BinaryReader binaryReader) Parameters binaryReader BinaryReader Returns UnityReader ExpandToUnityWriter(BinaryWriter) public static UnityWriter ExpandToUnityWriter(this BinaryWriter binaryWriter) Parameters binaryWriter BinaryWriter Returns UnityWriter"
  },
  "api/SaveSystem.Extensions.html": {
    "href": "api/SaveSystem.Extensions.html",
    "title": "Namespace SaveSystem.Extensions",
    "keywords": "Namespace SaveSystem.Extensions Classes BinaryHandlersExtensions"
  },
  "api/SaveSystem.Handlers.AbstractHandler-2.html": {
    "href": "api/SaveSystem.Handlers.AbstractHandler-2.html",
    "title": "Class AbstractHandler<T, TO>",
    "keywords": "Class AbstractHandler<T, TO> Base class for all object handlers Inheritance object AbstractHandler<T, TO> AsyncObjectHandler<TO> ObjectHandler<TO> SmartHandler<TO> Namespace: SaveSystem.Handlers Assembly: SaveSystem.dll Syntax public abstract class AbstractHandler<T, TO> where T : AbstractHandler<T, TO> Type Parameters Name Description T Type of handler TO Type of handled objects Constructors AbstractHandler(string, TO[], Func<TO>) protected AbstractHandler(string localFilePath, TO[] staticObjects, Func<TO> factoryFunc) Parameters localFilePath string staticObjects TO[] factoryFunc Func<TO> Fields dynamicObjects protected readonly List<TO> dynamicObjects Field Value List<TO> factoryFunc protected Func<TO> factoryFunc Field Value Func<TO> loadingProgress protected IProgress<float> loadingProgress Field Value IProgress<float> localFilePath protected readonly string localFilePath Field Value string savingProgress protected IProgress<float> savingProgress Field Value IProgress<float> staticObjects protected readonly TO[] staticObjects Field Value TO[] Methods AddObject(TO) Add a dynamic object that spawned at runtime public T AddObject(TO obj) Parameters obj TO Spawned object Returns T AddObjects(ICollection<TO>) Add some objects that spawned at runtime public T AddObjects(ICollection<TO> objects) Parameters objects ICollection<TO> Spawned objects Returns T ObserveProgress(IProgress<float>, IProgress<float>) You can hand over two IProgress objects to observe the progress of loading and saving data separately public T ObserveProgress(IProgress<float> savingProgress, IProgress<float> loadingProgress) Parameters savingProgress IProgress<float> Object that observes of saving progress loadingProgress IProgress<float> Object that observes of loading progress Returns T ObserveProgress(IProgress<float>) You can hand over IProgress object to observe the progress of data handling public T ObserveProgress(IProgress<float> progress) Parameters progress IProgress<float> Object that observes of handling progress Returns T SetFactoryFunc(Func<TO>) Add function for objects spawn. This is necessary to load dynamic objects public T SetFactoryFunc(Func<TO> factoryFunc) Parameters factoryFunc Func<TO> Returns T"
  },
  "api/SaveSystem.Handlers.AsyncObjectHandler-1.html": {
    "href": "api/SaveSystem.Handlers.AsyncObjectHandler-1.html",
    "title": "Class AsyncObjectHandler<TO>",
    "keywords": "Class AsyncObjectHandler<TO> It's same as Object Handler but works with objects that are saved and loaded asynchronously Inheritance object AbstractHandler<AsyncObjectHandler<TO>, TO> AsyncObjectHandler<TO> Implements IAsyncObjectHandler Namespace: SaveSystem.Handlers Assembly: SaveSystem.dll Syntax public sealed class AsyncObjectHandler<TO> : AbstractHandler<AsyncObjectHandler<TO>, TO>, IAsyncObjectHandler where TO : IPersistentObjectAsync Type Parameters Name Description TO Methods LoadAsync(CancellationToken) Call it to start async objects loading public UniTask<HandlingResult> LoadAsync(CancellationToken token = default) Parameters token CancellationToken Returns UniTask<HandlingResult> SaveAsync(CancellationToken) Call it to start async objects saving public UniTask<HandlingResult> SaveAsync(CancellationToken token = default) Parameters token CancellationToken Returns UniTask<HandlingResult>"
  },
  "api/SaveSystem.Handlers.HandlingResult.html": {
    "href": "api/SaveSystem.Handlers.HandlingResult.html",
    "title": "Enum HandlingResult",
    "keywords": "Enum HandlingResult Possible results enumeration of objects handling Namespace: SaveSystem.Handlers Assembly: SaveSystem.dll Syntax public enum HandlingResult"
  },
  "api/SaveSystem.Handlers.html": {
    "href": "api/SaveSystem.Handlers.html",
    "title": "Namespace SaveSystem.Handlers",
    "keywords": "Namespace SaveSystem.Handlers Classes AbstractHandler<T, TO> Base class for all object handlers AsyncObjectHandler<TO> It's same as Object Handler but works with objects that are saved and loaded asynchronously ObjectHandler<TO> Object Handler can help you to saving/loading persistent objects. Also you can set parameters for this as a chain of methods ObjectHandlersFactory Use it to create Object Handlers, and Async Object Handlers SmartHandler<TO> You can handle storable objects using this Interfaces IAsyncObjectHandler Defines methods for async object handling IObjectHandler Defines methods for simple object handling Enums HandlingResult Possible results enumeration of objects handling"
  },
  "api/SaveSystem.Handlers.IAsyncObjectHandler.html": {
    "href": "api/SaveSystem.Handlers.IAsyncObjectHandler.html",
    "title": "Interface IAsyncObjectHandler",
    "keywords": "Interface IAsyncObjectHandler Defines methods for async object handling Namespace: SaveSystem.Handlers Assembly: SaveSystem.dll Syntax public interface IAsyncObjectHandler Methods LoadAsync(CancellationToken) Call it to start async objects loading UniTask<HandlingResult> LoadAsync(CancellationToken token = default) Parameters token CancellationToken Returns UniTask<HandlingResult> SaveAsync(CancellationToken) Call it to start async objects saving UniTask<HandlingResult> SaveAsync(CancellationToken token = default) Parameters token CancellationToken Returns UniTask<HandlingResult>"
  },
  "api/SaveSystem.Handlers.IObjectHandler.html": {
    "href": "api/SaveSystem.Handlers.IObjectHandler.html",
    "title": "Interface IObjectHandler",
    "keywords": "Interface IObjectHandler Defines methods for simple object handling Namespace: SaveSystem.Handlers Assembly: SaveSystem.dll Syntax public interface IObjectHandler Methods Load() Call it to start objects loading HandlingResult Load() Returns HandlingResult Save() Call it to start objects saving void Save()"
  },
  "api/SaveSystem.Handlers.ObjectHandler-1.html": {
    "href": "api/SaveSystem.Handlers.ObjectHandler-1.html",
    "title": "Class ObjectHandler<TO>",
    "keywords": "Class ObjectHandler<TO> Object Handler can help you to saving/loading persistent objects. Also you can set parameters for this as a chain of methods Inheritance object AbstractHandler<ObjectHandler<TO>, TO> ObjectHandler<TO> Implements IObjectHandler Namespace: SaveSystem.Handlers Assembly: SaveSystem.dll Syntax public sealed class ObjectHandler<TO> : AbstractHandler<ObjectHandler<TO>, TO>, IObjectHandler where TO : IPersistentObject Type Parameters Name Description TO Methods Load() Call it to start objects loading public HandlingResult Load() Returns HandlingResult Save() Call it to start objects saving public void Save()"
  },
  "api/SaveSystem.Handlers.ObjectHandlersFactory.html": {
    "href": "api/SaveSystem.Handlers.ObjectHandlersFactory.html",
    "title": "Class ObjectHandlersFactory",
    "keywords": "Class ObjectHandlersFactory Use it to create Object Handlers, and Async Object Handlers Inheritance object ObjectHandlersFactory Namespace: SaveSystem.Handlers Assembly: SaveSystem.dll Syntax public static class ObjectHandlersFactory Properties RegisterImmediately Configure it to automatically register handlers in the Save System Core public static bool RegisterImmediately { get; set; } Property Value bool If true, the Handlers Provider will register all created handlers in the Core, otherwise you will have to do it manually (it's false by default) Methods CreateAsyncHandler<TO>(string, TO, string) Creates an async object handler that will saving and loading a single object async public static AsyncObjectHandler<TO> CreateAsyncHandler<TO>(string filePath, TO obj, string caller = \"\") where TO : IPersistentObjectAsync Parameters filePath string Path to save and load objects obj TO Objects which will be saved and loaded caller string For internal use (no need to pass it manually) Returns AsyncObjectHandler<TO> Type Parameters TO CreateAsyncHandler<TO>(string, ICollection<TO>, Func<TO>, string) Creates an object handler that will saving and loading some objects async public static AsyncObjectHandler<TO> CreateAsyncHandler<TO>(string filePath, ICollection<TO> objects, Func<TO> factoryFunc, string caller = \"\") where TO : IPersistentObjectAsync Parameters filePath string Path to save and load objects objects ICollection<TO> Objects which will be saved and loaded factoryFunc Func<TO> Function for objects spawn. This is necessary to load dynamic objects caller string For internal use (no need to pass it manually) Returns AsyncObjectHandler<TO> Type Parameters TO CreateAsyncHandler<TO>(string, ICollection<TO>, string) Creates an object handler that will saving and loading some objects async public static AsyncObjectHandler<TO> CreateAsyncHandler<TO>(string filePath, ICollection<TO> objects, string caller = \"\") where TO : IPersistentObjectAsync Parameters filePath string Path to save and load objects objects ICollection<TO> Objects which will be saved and loaded caller string For internal use (no need to pass it manually) Returns AsyncObjectHandler<TO> Type Parameters TO CreateAsyncHandler<TO>(string, Func<TO>, string) Creates an empty async handler public static AsyncObjectHandler<TO> CreateAsyncHandler<TO>(string filePath, Func<TO> factoryFunc, string caller = \"\") where TO : IPersistentObjectAsync Parameters filePath string Path to save and load objects factoryFunc Func<TO> Function for objects spawn. This is necessary to load dynamic objects caller string For internal use (no need to pass it manually) Returns AsyncObjectHandler<TO> Type Parameters TO CreateHandler<TO>(string, TO, string) Creates an object handler that will saving and loading a single object public static ObjectHandler<TO> CreateHandler<TO>(string filePath, TO obj, string caller = \"\") where TO : IPersistentObject Parameters filePath string Path to save and load objects obj TO Object which will be saved and loaded caller string For internal use (no need to pass it manually) Returns ObjectHandler<TO> Type Parameters TO CreateHandler<TO>(string, ICollection<TO>, Func<TO>, string) Creates an object handler that will saving and loading some objects public static ObjectHandler<TO> CreateHandler<TO>(string filePath, ICollection<TO> objects, Func<TO> factoryFunc, string caller = \"\") where TO : IPersistentObject Parameters filePath string Path to save and load objects objects ICollection<TO> Objects which will be saved and loaded factoryFunc Func<TO> Function for objects spawn. This is necessary to load dynamic objects caller string For internal use (no need to pass it manually) Returns ObjectHandler<TO> Type Parameters TO CreateHandler<TO>(string, ICollection<TO>, string) Creates an object handler that will saving and loading some objects public static ObjectHandler<TO> CreateHandler<TO>(string filePath, ICollection<TO> objects, string caller = \"\") where TO : IPersistentObject Parameters filePath string Path to save and load objects objects ICollection<TO> Objects which will be saved and loaded caller string For internal use (no need to pass it manually) Returns ObjectHandler<TO> Type Parameters TO CreateHandler<TO>(string, Func<TO>, string) Creates an empty handler public static ObjectHandler<TO> CreateHandler<TO>(string filePath, Func<TO> factoryFunc, string caller = \"\") where TO : IPersistentObject Parameters filePath string Path to save and load objects factoryFunc Func<TO> Function for objects spawn. This is necessary to load dynamic objects caller string For internal use (no need to pass it manually) Returns ObjectHandler<TO> Type Parameters TO CreateSmartHandler<TO>(string, TO, string) Creates a smart handler that will saving and loading a single storable object public static SmartHandler<TO> CreateSmartHandler<TO>(string filePath, TO obj, string caller = \"\") where TO : IStorable Parameters filePath string Path to save and load objects obj TO Objects which will be saved and loaded caller string For internal use (no need to pass it manually) Returns SmartHandler<TO> Type Parameters TO CreateSmartHandler<TO>(string, ICollection<TO>, Func<TO>, string) Creates a smart handler that will saving and loading some storable objects public static SmartHandler<TO> CreateSmartHandler<TO>(string filePath, ICollection<TO> objects, Func<TO> factoryFunc, string caller = \"\") where TO : IStorable Parameters filePath string Path to save and load objects objects ICollection<TO> Objects which will be saved and loaded factoryFunc Func<TO> Function for objects spawn. This is necessary to load dynamic objects caller string For internal use (no need to pass it manually) Returns SmartHandler<TO> Type Parameters TO CreateSmartHandler<TO>(string, ICollection<TO>, string) Creates a smart handler that will saving and loading some storable objects public static SmartHandler<TO> CreateSmartHandler<TO>(string filePath, ICollection<TO> objects, string caller = \"\") where TO : IStorable Parameters filePath string Path to save and load objects objects ICollection<TO> Objects which will be saved and loaded caller string For internal use (no need to pass it manually) Returns SmartHandler<TO> Type Parameters TO CreateSmartHandler<TO>(string, Func<TO>, string) Creates an empty smart handler public static SmartHandler<TO> CreateSmartHandler<TO>(string filePath, Func<TO> factoryFunc, string caller = \"\") where TO : IStorable Parameters filePath string Path to save and load objects factoryFunc Func<TO> Function for objects spawn. This is necessary to load dynamic objects caller string For internal use (no need to pass it manually) Returns SmartHandler<TO> Type Parameters TO"
  },
  "api/SaveSystem.Handlers.SmartHandler-1.html": {
    "href": "api/SaveSystem.Handlers.SmartHandler-1.html",
    "title": "Class SmartHandler<TO>",
    "keywords": "Class SmartHandler<TO> You can handle storable objects using this Inheritance object AbstractHandler<SmartHandler<TO>, TO> SmartHandler<TO> Implements IAsyncObjectHandler Namespace: SaveSystem.Handlers Assembly: SaveSystem.dll Syntax public class SmartHandler<TO> : AbstractHandler<SmartHandler<TO>, TO>, IAsyncObjectHandler where TO : IStorable Type Parameters Name Description TO Methods LoadAsync(CancellationToken) Call it to start async objects loading public UniTask<HandlingResult> LoadAsync(CancellationToken token = default) Parameters token CancellationToken Returns UniTask<HandlingResult> SaveAsync(CancellationToken) Call it to start async objects saving public UniTask<HandlingResult> SaveAsync(CancellationToken token = default) Parameters token CancellationToken Returns UniTask<HandlingResult>"
  },
  "api/SaveSystem.html": {
    "href": "api/SaveSystem.html",
    "title": "Namespace SaveSystem",
    "keywords": "Namespace SaveSystem Classes DataManager Main class for handling data DataManager.Advanced Contains the methods for advanced objects handling See manual Storage Use this class to get information about data Structs DataBuffer The buffer for writing and reading data from buffered objects MeshData Contains the data of a mesh. Mesh can be casted to MeshData and vice-versa Interfaces IPersistentObject You can implement it to mark your object as persistent IPersistentObjectAsync You can implement it to mark your object as persistent and also implement async handling IStorable Implement this for simplifed handling of your objects. It's easier in use than IPersistentObject Enums AsyncMode See manual"
  },
  "api/SaveSystem.IPersistentObject.html": {
    "href": "api/SaveSystem.IPersistentObject.html",
    "title": "Interface IPersistentObject",
    "keywords": "Interface IPersistentObject You can implement it to mark your object as persistent Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public interface IPersistentObject Methods Load(UnityReader) It will be called when system will loading data void Load(UnityReader reader) Parameters reader UnityReader UnityReader Save(UnityWriter) It will be called when system will saving data void Save(UnityWriter writer) Parameters writer UnityWriter UnityWriter"
  },
  "api/SaveSystem.IPersistentObjectAsync.html": {
    "href": "api/SaveSystem.IPersistentObjectAsync.html",
    "title": "Interface IPersistentObjectAsync",
    "keywords": "Interface IPersistentObjectAsync You can implement it to mark your object as persistent and also implement async handling Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public interface IPersistentObjectAsync Methods Load(UnityReader) It will be called when system will load data UniTask Load(UnityReader reader) Parameters reader UnityReader Returns UniTask Save(UnityWriter) It will be called when system will save data UniTask Save(UnityWriter writer) Parameters writer UnityWriter Returns UniTask"
  },
  "api/SaveSystem.IStorable.html": {
    "href": "api/SaveSystem.IStorable.html",
    "title": "Interface IStorable",
    "keywords": "Interface IStorable Implement this for simplifed handling of your objects. It's easier in use than IPersistentObject Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public interface IStorable Methods Load(DataBuffer) Gets DataBuffer and read data from this void Load(DataBuffer buffer) Parameters buffer DataBuffer Save() Writes some data to DataBuffer and return this DataBuffer Save() Returns DataBuffer"
  },
  "api/SaveSystem.MeshData.html": {
    "href": "api/SaveSystem.MeshData.html",
    "title": "Struct MeshData",
    "keywords": "Struct MeshData Contains the data of a mesh. Mesh can be casted to MeshData and vice-versa Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public struct MeshData Methods Equals(object) public override bool Equals(object obj) Parameters obj object Returns bool GetHashCode() public override int GetHashCode() Returns int Operators operator ==(MeshData, MeshData) public static bool operator ==(MeshData meshData1, MeshData meshData2) Parameters meshData1 MeshData meshData2 MeshData Returns bool implicit operator Mesh(MeshData) public static implicit operator Mesh(MeshData meshData) Parameters meshData MeshData Returns Mesh implicit operator MeshData(Mesh) public static implicit operator MeshData(Mesh mesh) Parameters mesh Mesh Returns MeshData operator !=(MeshData, MeshData) public static bool operator !=(MeshData meshData1, MeshData meshData2) Parameters meshData1 MeshData meshData2 MeshData Returns bool"
  },
  "api/SaveSystem.Storage.html": {
    "href": "api/SaveSystem.Storage.html",
    "title": "Class Storage",
    "keywords": "Class Storage Use this class to get information about data Inheritance object Storage Namespace: SaveSystem Assembly: SaveSystem.dll Syntax public static class Storage Methods GetDataSize() public static long GetDataSize() Returns long Returns the size of the data in bytes GetFormattedDataSize() public static string GetFormattedDataSize() Returns string Returns the formatted total data size Examples \"64 Bytes\", \"10.54 KBytes\", \"0.93 MBytes\" HasAnyData() public static bool HasAnyData() Returns bool True if local storage has any data, otherwise false"
  },
  "api/SaveSystem.UnityHandlers.html": {
    "href": "api/SaveSystem.UnityHandlers.html",
    "title": "Namespace SaveSystem.UnityHandlers",
    "keywords": "Namespace SaveSystem.UnityHandlers Classes UnityReader Adapter to class BinaryReader for simplify reading data UnityWriter Adapter to class BinaryWriter for simplify writing data"
  },
  "api/SaveSystem.UnityHandlers.UnityReader.html": {
    "href": "api/SaveSystem.UnityHandlers.UnityReader.html",
    "title": "Class UnityReader",
    "keywords": "Class UnityReader Adapter to class BinaryReader for simplify reading data Inheritance object UnityReader Implements IDisposable Namespace: SaveSystem.UnityHandlers Assembly: SaveSystem.dll Syntax public sealed class UnityReader : IDisposable Constructors UnityReader(BinaryReader, string) public UnityReader(BinaryReader reader, string fullPath = \"\") Parameters reader BinaryReader fullPath string Methods Dispose() public void Dispose() ReadBool() public bool ReadBool() Returns bool ReadByte() public byte ReadByte() Returns byte ReadBytes() public byte[] ReadBytes() Returns byte[] ReadBytesAsync() public UniTask<byte[]> ReadBytesAsync() Returns UniTask<byte[]> ReadChar() public char ReadChar() Returns char ReadChars() public char[] ReadChars() Returns char[] ReadCharsAsync() public UniTask<char[]> ReadCharsAsync() Returns UniTask<char[]> ReadColor() public Color ReadColor() Returns Color ReadColor32() public Color32 ReadColor32() Returns Color32 ReadColors() public Color[] ReadColors() Returns Color[] ReadColors32() public Color32[] ReadColors32() Returns Color32[] ReadColors32Async() public UniTask<Color32[]> ReadColors32Async() Returns UniTask<Color32[]> ReadColorsAsync() public UniTask<Color[]> ReadColorsAsync() Returns UniTask<Color[]> ReadDouble() public double ReadDouble() Returns double ReadDoubles() public double[] ReadDoubles() Returns double[] ReadDoublesAsync() public UniTask<double[]> ReadDoublesAsync() Returns UniTask<double[]> ReadFloat() public float ReadFloat() Returns float ReadFloats() public float[] ReadFloats() Returns float[] ReadFloatsAsync() public UniTask<float[]> ReadFloatsAsync() Returns UniTask<float[]> ReadInt() public int ReadInt() Returns int ReadIntArray() public int[] ReadIntArray() Returns int[] ReadIntArrayAsync() public UniTask<int[]> ReadIntArrayAsync() Returns UniTask<int[]> ReadLong() public long ReadLong() Returns long ReadLongArray() public long[] ReadLongArray() Returns long[] ReadLongArrayAsync() public UniTask<long[]> ReadLongArrayAsync() Returns UniTask<long[]> ReadMatrices() public Matrix4x4[] ReadMatrices() Returns Matrix4x4[] ReadMatricesAsync() public UniTask<Matrix4x4[]> ReadMatricesAsync() Returns UniTask<Matrix4x4[]> ReadMatrix() public Matrix4x4 ReadMatrix() Returns Matrix4x4 ReadMesh() public MeshData ReadMesh() Returns MeshData ReadMeshAsync() public UniTask<MeshData> ReadMeshAsync() Returns UniTask<MeshData> ReadObject<T>() public T ReadObject<T>() Returns T Type Parameters T ReadObjectsArray<T>() public T[] ReadObjectsArray<T>() Returns T[] Type Parameters T ReadObjectsArrayAsync<T>() public UniTask<T[]> ReadObjectsArrayAsync<T>() Returns UniTask<T[]> Type Parameters T ReadRotation() public Quaternion ReadRotation() Returns Quaternion ReadShort() public short ReadShort() Returns short ReadShorts() public short[] ReadShorts() Returns short[] ReadShortsAsync() public UniTask<short[]> ReadShortsAsync() Returns UniTask<short[]> ReadString() public string ReadString() Returns string ReadStringArray() public string[] ReadStringArray() Returns string[] ReadStringArrayAsync() public UniTask<string[]> ReadStringArrayAsync() Returns UniTask<string[]> ReadVector2() public Vector2 ReadVector2() Returns Vector2 ReadVector2Array() public Vector2[] ReadVector2Array() Returns Vector2[] ReadVector2ArrayAsync() public UniTask<Vector2[]> ReadVector2ArrayAsync() Returns UniTask<Vector2[]> ReadVector3() public Vector3 ReadVector3() Returns Vector3 ReadVector3Array() public Vector3[] ReadVector3Array() Returns Vector3[] ReadVector3ArrayAsync() public UniTask<Vector3[]> ReadVector3ArrayAsync() Returns UniTask<Vector3[]> ReadVector4() public Vector4 ReadVector4() Returns Vector4 ReadVector4Array() public Vector4[] ReadVector4Array() Returns Vector4[] ReadVector4ArrayAsync() public UniTask<Vector4[]> ReadVector4ArrayAsync() Returns UniTask<Vector4[]> ReadVersion() public Version ReadVersion() Returns Version"
  },
  "api/SaveSystem.UnityHandlers.UnityWriter.html": {
    "href": "api/SaveSystem.UnityHandlers.UnityWriter.html",
    "title": "Class UnityWriter",
    "keywords": "Class UnityWriter Adapter to class BinaryWriter for simplify writing data Inheritance object UnityWriter Implements IDisposable IAsyncDisposable Namespace: SaveSystem.UnityHandlers Assembly: SaveSystem.dll Syntax public sealed class UnityWriter : IDisposable, IAsyncDisposable Constructors UnityWriter(BinaryWriter, string) public UnityWriter(BinaryWriter writer, string fullPath = \"\") Parameters writer BinaryWriter fullPath string Methods Dispose() public void Dispose() DisposeAsync() public ValueTask DisposeAsync() Returns ValueTask Write(MeshData) public void Write(MeshData mesh) Parameters mesh MeshData Write(bool) public void Write(bool boolValue) Parameters boolValue bool Write(byte) public void Write(byte byteValue) Parameters byteValue byte Write(byte[]) public void Write(byte[] bytes) Parameters bytes byte[] Write(char) public void Write(char charValue) Parameters charValue char Write(char[]) public void Write(char[] chars) Parameters chars char[] Write(IEnumerable<byte>) public void Write(IEnumerable<byte> bytes) Parameters bytes IEnumerable<byte> Write(IEnumerable<char>) public void Write(IEnumerable<char> chars) Parameters chars IEnumerable<char> Write(IEnumerable<double>) public void Write(IEnumerable<double> doubles) Parameters doubles IEnumerable<double> Write(IEnumerable<short>) public void Write(IEnumerable<short> shorts) Parameters shorts IEnumerable<short> Write(IEnumerable<int>) public void Write(IEnumerable<int> ints) Parameters ints IEnumerable<int> Write(IEnumerable<long>) public void Write(IEnumerable<long> longs) Parameters longs IEnumerable<long> Write(IEnumerable<float>) public void Write(IEnumerable<float> floats) Parameters floats IEnumerable<float> Write(IEnumerable<string>) public void Write(IEnumerable<string> strings) Parameters strings IEnumerable<string> Write(IEnumerable<Color>) public void Write(IEnumerable<Color> colors) Parameters colors IEnumerable<Color> Write(IEnumerable<Color32>) public void Write(IEnumerable<Color32> colors32) Parameters colors32 IEnumerable<Color32> Write(IEnumerable<Matrix4x4>) public void Write(IEnumerable<Matrix4x4> matrices) Parameters matrices IEnumerable<Matrix4x4> Write(IEnumerable<Vector2>) public void Write(IEnumerable<Vector2> vector2Collection) Parameters vector2Collection IEnumerable<Vector2> Write(IEnumerable<Vector3>) public void Write(IEnumerable<Vector3> vector3Collection) Parameters vector3Collection IEnumerable<Vector3> Write(IEnumerable<Vector4>) public void Write(IEnumerable<Vector4> vector4Collection) Parameters vector4Collection IEnumerable<Vector4> Write(double) public void Write(double doubleValue) Parameters doubleValue double Write(double[]) public void Write(double[] doubles) Parameters doubles double[] Write(short) public void Write(short shortValue) Parameters shortValue short Write(short[]) public void Write(short[] shorts) Parameters shorts short[] Write(int) public void Write(int intValue) Parameters intValue int Write(int[]) public void Write(int[] ints) Parameters ints int[] Write(long) public void Write(long longValue) Parameters longValue long Write(long[]) public void Write(long[] longs) Parameters longs long[] Write(float) public void Write(float floatValue) Parameters floatValue float Write(float[]) public void Write(float[] floats) Parameters floats float[] Write(string) public void Write(string stringValue) Parameters stringValue string Write(string[]) public void Write(string[] strings) Parameters strings string[] Write(Version) public void Write(Version version) Parameters version Version Write(Color) public void Write(Color color) Parameters color Color Write(Color[]) public void Write(Color[] colors) Parameters colors Color[] Write(Color32) public void Write(Color32 color32) Parameters color32 Color32 Write(Color32[]) public void Write(Color32[] colors32) Parameters colors32 Color32[] Write(Matrix4x4) public void Write(Matrix4x4 matrix) Parameters matrix Matrix4x4 Write(Matrix4x4[]) public void Write(Matrix4x4[] matrices) Parameters matrices Matrix4x4[] Write(Quaternion) public void Write(Quaternion rotation) Parameters rotation Quaternion Write(Vector2) public void Write(Vector2 vector2) Parameters vector2 Vector2 Write(Vector2[]) public void Write(Vector2[] vector2Array) Parameters vector2Array Vector2[] Write(Vector3) public void Write(Vector3 vector3) Parameters vector3 Vector3 Write(Vector3[]) public void Write(Vector3[] vector3Array) Parameters vector3Array Vector3[] Write(Vector4) public void Write(Vector4 vector4) Parameters vector4 Vector4 Write(Vector4[]) public void Write(Vector4[] vector4Array) Parameters vector4Array Vector4[] WriteAsync(MeshData) public UniTask WriteAsync(MeshData mesh) Parameters mesh MeshData Returns UniTask WriteAsync(IEnumerable<byte>) public UniTask WriteAsync(IEnumerable<byte> bytes) Parameters bytes IEnumerable<byte> Returns UniTask WriteAsync(IEnumerable<char>) public UniTask WriteAsync(IEnumerable<char> chars) Parameters chars IEnumerable<char> Returns UniTask WriteAsync(IEnumerable<double>) public UniTask WriteAsync(IEnumerable<double> doubles) Parameters doubles IEnumerable<double> Returns UniTask WriteAsync(IEnumerable<short>) public UniTask WriteAsync(IEnumerable<short> shorts) Parameters shorts IEnumerable<short> Returns UniTask WriteAsync(IEnumerable<int>) public UniTask WriteAsync(IEnumerable<int> ints) Parameters ints IEnumerable<int> Returns UniTask WriteAsync(IEnumerable<long>) public UniTask WriteAsync(IEnumerable<long> longs) Parameters longs IEnumerable<long> Returns UniTask WriteAsync(IEnumerable<float>) public UniTask WriteAsync(IEnumerable<float> floats) Parameters floats IEnumerable<float> Returns UniTask WriteAsync(IEnumerable<string>) public UniTask WriteAsync(IEnumerable<string> strings) Parameters strings IEnumerable<string> Returns UniTask WriteAsync(IEnumerable<Color>) public UniTask WriteAsync(IEnumerable<Color> colors) Parameters colors IEnumerable<Color> Returns UniTask WriteAsync(IEnumerable<Color32>) public UniTask WriteAsync(IEnumerable<Color32> colors32) Parameters colors32 IEnumerable<Color32> Returns UniTask WriteAsync(IEnumerable<Matrix4x4>) public UniTask WriteAsync(IEnumerable<Matrix4x4> matrices) Parameters matrices IEnumerable<Matrix4x4> Returns UniTask WriteAsync(IEnumerable<Vector2>) public UniTask WriteAsync(IEnumerable<Vector2> vector2Collection) Parameters vector2Collection IEnumerable<Vector2> Returns UniTask WriteAsync(IEnumerable<Vector3>) public UniTask WriteAsync(IEnumerable<Vector3> vector3Collection) Parameters vector3Collection IEnumerable<Vector3> Returns UniTask WriteAsync(IEnumerable<Vector4>) public UniTask WriteAsync(IEnumerable<Vector4> vector4Collection) Parameters vector4Collection IEnumerable<Vector4> Returns UniTask WriteObject<T>(T) public void WriteObject<T>(T obj) Parameters obj T Type Parameters T WriteObjects<T>(IEnumerable<T>) public void WriteObjects<T>(IEnumerable<T> objects) Parameters objects IEnumerable<T> Type Parameters T WriteObjectsArray<T>(T[]) public void WriteObjectsArray<T>(T[] arrayObjects) Parameters arrayObjects T[] Type Parameters T WriteObjectsAsync<T>(IEnumerable<T>) public UniTask WriteObjectsAsync<T>(IEnumerable<T> objects) Parameters objects IEnumerable<T> Returns UniTask Type Parameters T"
  },
  "changelog/CHANGELOG.html": {
    "href": "changelog/CHANGELOG.html",
    "title": "Changelog",
    "keywords": "Changelog [1.6.0] - 2023-10-02 Added Added new feature - saving and loading data using a data buffer Added new structure - DataBuffer Added new interface - IStorable, the interface implemented by objects that write data to DataBuffer and read data from it Added new handler - SmartHandler, the new handler handles IStorable objects Changed Unity handlers was separated as buffering and direct. Buffering handlers write and read data using MemoryStream, direct handlers write and read data using FileStream Fixed Fixed missing validation in the DataManager methods parameters Fixed missing validation in the SaveSystemCore properties [1.5.0] - 2023-09-28 Added Added Object Handlers. You can use these instead of the obsolete DataManager class methods Added Checkpoints. You can set checkpoints in a scene in the editor, or at runtime by use the CheckPointsCreator class Added the Save System Core. This is a new subsystem that can save your objects and handlers in the internal loop, during a quick-save and when the player hits any checkpoint Changed Advanced methods have been moved to the Advanced class - the nested class within the DataManager. These methods have been renamed Data handlers (UnityWriter, UnityReader, etc.) have been moved to SaveSystem.UnityHandlers namespace Fixed Fixed catching the exception that throws when the binary reader is null Fixed file deleting when canceling a save, now UnityWriter writes data to a memory stream instead of writing directly to the file [1.4.0] - 2023-04-22 Added Added asynchronous data handling: Added new interface - the IPersistentObjectAsync for asynchronous handling of objects Expanded UnityWriter and UnityReader handlers - added asynchronous methods in them to write and read data Expanded the DataManager - added asynchronous methods to save and load objects Changed Removed write and read meshes array methods Removed methods for writing and reading a list of objects. Instead, use the write and read methods of an array of objects. Removed methods for saving and loading a list of objects from the DataManager. Instead, use the save and load methods of an array of objects. [1.3.0] - 2023-04-17 Added Added write and read mesh and meshes array methods Added methods for writing and reading arrays of basic data types and unity structures Changed Removed methods for writing and reading MonoBehaviour classes. Use SaveObject method instead and implement the IPersistentObject interface in your MonoBehaviour classes [1.2.0] - 2023-04-15 Added Added methods for writing and reading unity structures such as Color32, Matrix4X4, Vector2, Vector4. Added methods for writing and reading classes which inherits from MonoBehaviour Changed Renamed \"ReadPosition\" method to \"ReadVector3\" (in UnityReader class) Fixed Fixed problem with writing data to file. UnityWriter was leaving \"trash\" bytes at the end of the file if it wrote fewer bytes than the file contains [1.1.1] - 2023-04-14 Added Added displaying of size of data (in \"Data Manager / Get Data Size\" menu in editor) [1.1.0] - 2023-04-14 Added Added support of saving single object and list of objects [1.0.0] - 2023-04-13 Added Create package"
  },
  "index.html": {
    "href": "index.html",
    "title": "Welcome to the documentation of the Save System",
    "keywords": "Welcome to the documentation of the Save System See Manual for quick start See Scripting API to more details of system usage See Changelog to know latest changes in the system"
  },
  "license/LICENSE.html": {
    "href": "license/LICENSE.html",
    "title": "",
    "keywords": "MIT License Copyright (c) 2023 Denis Dmitriev Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "manual/installing.html": {
    "href": "manual/installing.html",
    "title": "Installing",
    "keywords": "Installing Do these steps to install the package: Click on the green button \"Code\" Then click on copy button, in \"HTTPS\" tab In Unity open the Package Manager window (Window/Package Manager) Then click on plus sign and select \"Add package from git URL\" Insert copied link and click on \"Add\" After a while the package will be added to your project However, you can see some errors in the debug console. The save system has a dependency on UniTask. Unfortunately, Unity Package Manager cannot resolve dependencies between Git repositories, so you need to install UniTask manually. Copy this link https://github.com/Cysharp/UniTask.git?path=src/UniTask/Assets/Plugins/UniTask and install UniTask in the same way as you installed the save system"
  },
  "manual/intro.html": {
    "href": "manual/intro.html",
    "title": "About Save System",
    "keywords": "About Save System The save system is a package for saving and loading game data. This system allows you to save the state of the game at a some moment (ex. before quitting) and restore it after entering. You can choose one of the following ways to commit the state of the game: Synchronous Asynchronous single threading mode (on the player loop) Asynchronous multithreading mode (on the thread pool) In low level you can control unity structures such as Vector2, Vector3, Vector4, Quaternion, Color, Color32, Matrix4X4, Mesh. Also you can write down and read base data types and custom classes and structures. Installing Read Installing Manual to install this package Using Save System See Using Save System to learn how to use this system"
  },
  "manual/using_save_system/advanced.html": {
    "href": "manual/using_save_system/advanced.html",
    "title": "Advanced data handling",
    "keywords": "Warning The documentation contains the information about obsolete API Advanced data handling In 99% cases you won't need to this, but you can write and read data asynchronously by using UnityWriter and UnityReader. In past examples only objects was saved asynchronously, but inside them data was written sync public void Save (UnityWriter writer) { writer.Write(myData); } Instead, you can write down data async in the same way as saving objects public async UniTask Save (UnityWriter writer) { await writer.WriteAsync(myData); } To do this, class of object must be implement the IPersistentObjectAsync interface instead of the IPersistentObject public class MyObject : IPersistentObjectAsync { public async UniTask Save (UnityWriter writer) { } public async UniTask Load (UnityReader reader) { } } To save the object, you can pass it to DataManager.Advanced.SaveObjectAsync() method await DataManager.Advanced.SaveObjectAsync(fileName, myObject); Notice that you don't pass AsyncMode to either Advanced.SaveObjectAsync() method, or the data handlers, because the data handlers handle data the same in both modes, so only one mode was chosen which support in every platforms. Separately about the mesh If you're generating a mesh with more than one uv channel and want to write down the generated mesh, you must pass the number of channels to the WriteAsync() method await writer.WriteAsync(generatedMeshData, uvChannels: 2); Similarly with reading generatedMeshData = await reader.ReadMeshAsync(uvChannels: 2); By default, asynchronous data handlers write and read one uv channel When I need to this You can use this when your objects have big arrays of data. In this case, you can split the job of writing and reading data. The every array will be read/write in a separate frame"
  },
  "manual/using_save_system/advice.html": {
    "href": "manual/using_save_system/advice.html",
    "title": "Backward compatibility advice",
    "keywords": "Backward compatibility advice For backward compatibility of your data files, it is recommended define the data reading logic based on the data file version. For this, you will write a version of the file, then read its from the data file and at the end reading data depending on the file version You can do it into any class by using any data handler. You can use Version class from System namespace and bind the file version to an application version private readonly Version m_currentVersion = new Version(Application.version); Let's say you decided to add some data to persist and then read its. If you read the old file which doesn't contain this data, you will get the EndOfStreamException, because the UnityReader will try to read more bytes than the data file contains. The following code example shows how to read data depending on the file version private readonly Version m_oldVersion1 = new Version(\"1.0.0\"); private readonly Version m_oldVersion2 = new Version(\"1.1.0\"); private readonly Version m_currentVersion = new Version(Application.version); // 1.2.0 public void Save (UnityWriter writer) { writer.Write(m_currentVersion); // other actions } public void Load (UnityReader reader) { var readVersion = reader.ReadVersion(); if (readVersion >= m_oldVersion1) { // performing some actions depending on the file version } // other actions if (readVersion >= m_oldVersion2) { // performing some actions depending on the file version } // other actions if (readVersion == m_currentVersion) { // performing some actions depending on the file version } } This is where you store old versions of your file, read the version of the data file, compare it to old versions and current version and read other data based on the read file version. You can choose an other way for persist the old versions (ex. in StreamingAssets folder in json file, or in some other way). The main thing is that you was comparing the file version to the old versions and the current one"
  },
  "manual/using_save_system/async-management.html": {
    "href": "manual/using_save_system/async-management.html",
    "title": "Asynchronous management",
    "keywords": "Warning The documentation contains the information about obsolete API Asynchronous management DataManager can also save and load objects asynchronously. For example, if you're generating a heavy mesh and want to write down it, you wouldn't want to do it at runtime, else your game will freeze. To do it you can persist MyGenerator by using SaveObjectAsync() method. You can await it or continue public async void Saving () { await DataManager.SaveObjectAsync(fileName, myGenerator, AsyncMode.OnThreadPool); // some actions } // or public void Saving () { DataManager.SaveObjectAsync(fileName, myGenerator, AsyncMode.OnThreadPool); // some actions } And then in MyGenerator you can write the mesh public void Save (UnityWriter writer) { writer.Write(m_meshData); } Note Before write down the mesh, you must get MeshData struct inside an other method and save it as class field to pass it to writer.Write method. You just can cast Mesh to MeshData, ex. public class MyGenerator : IPersistentObject { private MeshData m_meshData; private Mesh m_generatedMesh; public void PreSave () { m_meshData = m_generatedMesh; } // other actions } For more information about AsyncMode, see the chapter async modes If you are saving a lot of objects, you can observe the progress by passing a object to the DataManager which implement the IProgress<float> interface var progress = new Progress(); // it implements the IProgress<float> interface await DataManager.SaveObjectsAsync( fileName, myObjects, AsyncMode.OnThreadPool, progress ); Also you can cancel operation by passing the cancellation token source to the DataManager var source = new CancellationTokenSource(); DataManager.SaveObjectsAsync( fileName, myObjects, AsyncMode.OnThreadPool, source: source ); // some actions source.Cancel(); If you cancel the save, DataManager will delete the save file. Finally you can pass a lambda to the manager. The lambda will be called after the completion of the process DataManager.SaveObjectsAsync( fileName, myObjects, AsyncMode.OnThreadPool, onComplete: () => Debug.Log(\"Objects saved\") ); When you load objects, you can await the result in the same way as when you load objects synchronously public async void Loading () { if (await DataManager.LoadObjectsAsync(fileName, myObjects, AsyncMode.OnThreadPool)) { // some actions } }"
  },
  "manual/using_save_system/async-modes.html": {
    "href": "manual/using_save_system/async-modes.html",
    "title": "Async modes",
    "keywords": "Warning The documentation contains the information about obsolete API Async modes You can choose how to save and load objects - in the player loop or in the thread pool. For example, to save objects in the player loop you must pass AsyncMode.OnPlayerLoop mode to SaveObject method await DataManager.SaveObjectAsync(fileName, myObjects, AsyncMode.OnPlayerLoop); Async mode defines where the objects will be saved - in the main thread (in the player loop, single thread mode), or in a background (in the thread pool, multithreading mode). Tip Running in the thread pool will be faster than running in the player loop, other things being equal If you save one object in the player loop asynchronously, it will be equivalent to synchronous save (however, in this case onComplete action will be called in the next frame) How to choose async mode Usually you will write down and read data in the thread pool, especially if you are saving and loading a lot of objects. But if you can't use multithreading (ex. when you're creating a game for the WebGL platform), you need to select a saving/loading in the player loop. AsyncMode Threading mode OnPlayerLoop The main thread usage OnThreadPool A background thread usage"
  },
  "manual/using_save_system/checkpoints.html": {
    "href": "manual/using_save_system/checkpoints.html",
    "title": "Checkpoints",
    "keywords": "Checkpoints Sometimes we need saving the player progress at some physical point. You can create such points in the editor or at runtime. Creating checkpoints in the editor In the scene view in the toolbar you can see Check Points Creator tool Click on this or tap \"C\" button on keyboard and the tool will activate. In the upper left corner there is a Create Check Point button When you create your first checkpoint, also other buttons will be displayed in the view The tool supports multiply points editing In code There are 2 commands to quickly create checkpoints at runtime CheckPointsFactory.CreateCheckPoint(Vector3 position, float radius = 0.5f); CheckPointsFactory.CreateCheckPoint2D(Vector2 position, float radius = 0.5f);"
  },
  "manual/using_save_system/data-buffer.html": {
    "href": "manual/using_save_system/data-buffer.html",
    "title": "Handle objects using data buffer",
    "keywords": "Handle objects using data buffer The Save System provides a more convenient way for data handling. You can implement IStorable interface in your objects for simplified writing and reading data using DataBuffer structure: public class MyObject : MonoBehaviour, IStorable { private MeshRenderer m_renderer; public DataBuffer Save () { return new DataBuffer { vector3 = transform.position, quaternion = transfrom.rotation, color = m_renderer.material.color }; } public void Load (DataBuffer buffer) { m_renderer.material.color = buffer.color; transform.position = buffer.vector3; transform.rotation = buffer.quaternion } } And then pass it to SmartHandler: m_smartHalder = ObjectHandlersFactory.CreateSmartHandler(m_filePath, m_object); // some actions await m_smartHalder.SaveAsync(); Passing of the cancellation token has no effect. The SmartHandler can be passed to SaveSystemCore just like others (see this part about SaveSystemCore) SaveSystemCore.RegisterAsyncHandler(m_smartHalder); What are the benefits of this approach? You don't have to worry about the order of writing and reading. Data collecting is processed by synchronously, the system receives a snapshot of data in once game frame and then writes data asynchronously. Since data writing cannot be canceled, the data will be written to file immediately and then it'll take up less memory."
  },
  "manual/using_save_system/dynamic-objects-handling.html": {
    "href": "manual/using_save_system/dynamic-objects-handling.html",
    "title": "Dynamic objects handling",
    "keywords": "Dynamic objects handling Let's first define the terms - by static objects we mean such objects that are already in the scene and will never be destroyed; By dynamic objects we mean such objects that aren't initially in the scene, but they'll be spawned later. You can create empty ObjectHandler (that hasn't any static objects) and pass dynamic objects to it later, but first you should pass a factory function to it (this is necessary to automatically spawn dynamic objects before loading) m_handler = ObjectHandlersFactory.CreateHandler( filePath, () => Object.Instantiate(m_prefab) ); m_handler.Load(); // ... m_handler.AddObject(m_spawnedObject); Also you can pass the factory function to other handlers m_oldHandler.SetFactoryFunc(() => Object.Instantiate(m_prefab)); This allows you to choose an objects spawn method other than the default. For example, you use Zenject framework and you need to create an object from a factory to inject dependencies into it, so, you could write m_oldHandler.SetFactoryFunc(() => m_factory.Create(m_prefab)); The handlers automatically remove destroyed objects before saving"
  },
  "manual/using_save_system/in-editor.html": {
    "href": "manual/using_save_system/in-editor.html",
    "title": "Editor console",
    "keywords": "Editor console In the unity editor there is a button to open the console In this window there are 2 tabs to get more information about a saved data and object handlers (Saved Files tab and Handlers Tracker) Also there is a Settings tab where you can configure the system"
  },
  "manual/using_save_system/object-handlers.html": {
    "href": "manual/using_save_system/object-handlers.html",
    "title": "Object Handlers",
    "keywords": "Object Handlers If you read \"Asynchronous Management\" chapter, you may have noticed that using the DataManager's async methods is a few fiddly. ObjectHandler and AsyncObjectHandler classes was created for this reason. Just look to example: // Earlier you was forced to use this method await DataManager.SaveObjectsAsync( fileName, myObjects, AsyncMode.OnThreadPool, onComplete: () => Debug.Log(\"Objects saved\") ); // However you can use Object Handler class instead this HandlingResult result = await ObjectHandlersFactory .CreateAsyncHandler(myObjects, fileName) .SaveAsync(); if (result == HandlingResult.Success) Debug.Log(\"Objects saved\"); One important change - AsyncObjectHandler doesn't accept onComplete callback, it returns HandlingResult instead this. More about the handlers In short, the ObjectHandler created for handling of objects which implement IPersistentObject interface. The AsyncObjectHandler handle IPersistentObjectAsync objects. None of them support async modes, but you still can pass IProgress<float> object to observe progress await asyncHandler.ObserveProgress(m_progress).SaveAsync(); // or await asyncHandler.ObserveProgress(m_savingProgress, m_loadingProgress).SaveAsync(); Also you can create an ObjectHandler, set its parameters and call saving later: private ObjectHandler<MyObject> m_handler; private MyObject[] m_objects; private void Start() { m_handler = ObjectHandlersFactory.CreateHandler( localFilePath: \"MyGameProgress/GameObjects.bytes\", m_objects ); } private void OnApplicationQuit() { m_handler.Save(); } If you need to async save objects on the thread pool, you can write await Task.Run(handler.Save, cancellationToken: token); // or await UniTask.RunOnThreadPool(() => handler.Save(), cancellationToken: token); The AsyncObjectHandler accepts a cancellation token unlike the DataManager (it accepts a cancellation token source). await DataManager.SaveObjectsAsync(filePath, objects, AsyncMode.OnPlayerLoop, source: m_tokenSource); await asyncObjectHandler.SaveAsync(m_tokenSource.Token); Since an async data processing can be canceled, AsyncObjectHandler will be write the data to the buffer at first, and then to a file. Otherwise (if it'll write directly to a file), when canceling the operation, the data would be considered invalid. This protects the file, but writes a more bytes than directly writing."
  },
  "manual/using_save_system/objects-control.html": {
    "href": "manual/using_save_system/objects-control.html",
    "title": "Objects control",
    "keywords": "Objects control In addition to unity structures and base data types, you can write down and read custom classes and structures. writer.Write<MyClass>(myClass); myClass = reader.ReadObject<MyClass>(); To write down (not save) a custom class, it must be serializable [Serializable] public class MyClass { public int intValue; // it will be saved [SerializeField] private bool boolValue; // and this private int m_intValue; // but not this public bool BoolValue { get; set; } // and not this } By default, its will be written as json string. If you want to override this, you can define extensions. For example public static class SaveSystemExtensions { public static void WriteMyClass (this UnityWriter writer, MyClass myClass) { writer.Write(myClass.position); writer.Write(myClass.rotation); writer.Write(myClass.boolValue); writer.Write(myClass.intValue); } public static MyClass ReadMyClass (this UnityReader reader) { return new MyClass { position = reader.ReadVector3(), rotation = reader.ReadRotation(), boolValue = reader.ReadBool(), intValue = reader.ReadInt() }; } } After then you can write down the class and read its as binary writer.WriteMyClass(myClass); myClass = reader.ReadMyClass();"
  },
  "manual/using_save_system/save-system-core.html": {
    "href": "manual/using_save_system/save-system-core.html",
    "title": "The Save System Core",
    "keywords": "The Save System Core All this time you were forced to manually handle objects. But now you can create handler and pass it into the SaveSystemCore The SaveSystemCore is the system which supports 6 saving methods: Quick-save - just call QuickSave() method or bind any key using BindKey(KeyCode keyCode) method. Save at checkpoint - when the player reaches any checkpoint, the Core will automatically save the game. Auto save - SaveSystemCore can save the game automatically during each period which you configure using SavePeriod property. Save on exit - also it can save the game during the quitting. Save on focus lost - if the application loses focus (ex. the player minimized the app), SaveSystemCore will save the game immediately. Save on low memory - if there is low memory left on the device, the application receives a notification and the game will be saved. Internally, the SaveSystemCore uses ObjectHandler and AsyncObjectHandler to save. So it can do this, you should register handlers. SaveSystemCore.RegisterObjectHandler(m_handler); SaveSystemCore.RegisterAsyncObjectHandler(m_asyncHandler); Also you can enable RegisterImmediately property in ObjectHandlersFactory and then create handlers. ObjectHandlersFactory.RegisterImmediately = true; ObjectHandlersFactory.CreateHandler(filePath, objects); // this handler will be registered automatically ObjectHandlersFactory.CreareAsyncHandler(filePath, asyncObjects); // and this Save Events The auto save, save on exit, save on focus lost and save on low memory are events which you can configure using the EnabledSaveEvents property in the SaveSystemCore. SaveSystemCore.EnabledSaveEvents = SaveEvents.AutoSave | SaveEvents.OnExit; // if you want to enable all events SaveSystemCore.EnabledSaveEvents = SaveEvents.All; Parallel saving To speed up saving on multi-core devices, you can enable IsParallel property. SaveSystemCore.IsParallel = true; Important Not recommended unless your objects are thread safe. Other parameters Also you can enable debug messages from SaveSystemCore. SaveSystemCore.DebugEnabled = true; It will write all logs in the debug console (warnings and errors will be written regardless of settings). Configure checkpoints destroying after saving at checkpoint: SaveSystemCore.DestroyCheckPoints = true; And pass player tag (is used to filtering messages from triggered checkpoints): SaveSystemCore.PlayerTag = \"Player\"; Configure all parameters in code: SaveSystemCore.ConfigureParameters( enabledSaveEvents: SaveEvents.AutoSave | SaveEvents.OnExit, isParallel: false, debugEnabled: false, destroyCheckPoints: true, playerTag: \"Player\", savePeriod: 15 ); All these parameters you can configure in the console: Save on exit Its worth mentioning separately about saving before exiting the game. Since there is no way to wait saving asynchronously in this case, the SaveSystemCore run saving of async handlers on the thread pool and waits them in the main thread. Because saving run on the thread pool, your async objects must be thread safe. But otherwise you can call SaveAndQuit(): await SaveSystemCore.SaveAndQuit(); // there shouldn't be any code after this as SaveSystemCore will close the application However, it isn't always known when to call it: the player can exit the game at any time in any way, so automatic saving may be more reliable (but you can combine these methods, manual saving cancels automatic saving). Anyway the choice is yours. Observe progress You can pass IProgress<float> object in the same way you pass it to handlers: SaveSystemCore.ObserveProgress(m_savingProgress); And you can subscribe to 2 events - OnSaveStart and OnSaveEnd: SaveSystemCore.OnSaveStart += saveType => { if (saveType == SaveType.AutoSave) // some actions if (saveType == SaveType.SaveAtCheckpoint) // and so on } SaveSystemCore.OnSaveEnd += saveType => { // similarly }"
  },
  "manual/using_save_system/saving-and-loading.html": {
    "href": "manual/using_save_system/saving-and-loading.html",
    "title": "Saving and loading objects",
    "keywords": "Saving and loading objects DataManager is the main class for data management. It contains several methods for loading and saving objects. If you want to keep a MonoBehaviour object, you can write var myObject = FindObjectOfType<MyObject>(); DataManager.SaveObject(fileName, myObject); // \"fileName\" is the name of the data file without // full path and its extension (ex. \"myDataFile\") To load the object if (DataManager.LoadObject(fileName, myObject)) { // some actions } The LoadObject() method returns true if it successfully loaded object. It returns false if a save file is missing. The class of object must implement the IPersistentObject interface and Save() and Load() methods. public class MyObject : MonoBehaviour, IPersistentObject { public void Save (UnityWriter writer) { } public void Load (UnityReader reader) { } } The DataManager can also save and load multiple objects as array Also you can pass your objects to ObjectHandler and AsyncObjectHandler. Read this article for more information"
  },
  "manual/using_save_system/using.html": {
    "href": "manual/using_save_system/using.html",
    "title": "Using Save System",
    "keywords": "Using Save System Saving and loading data consist of the following steps: Implement the IPersistentObject or IPersistentObjectAsync interface in your object Implement Save and Load methods in it: Write down data in the save method by using UnityWriter Read data in the load method by using UnityReader Pass the object to the DataManager: Pass it to SaveObject() method for saving Or pass it to LoadObject() to load Or pass them to the ObjectHandler or AsyncObjectHander and then pass the handlers to the SaveSystemCore See saving and loading data for more information about using of the DataManager Then see writing and reading data for more about of the UnityWriter and the UnityReader Other useful articles: Object Handlers Checkpoints The Save System Core"
  },
  "manual/using_save_system/writing-and-reading.html": {
    "href": "manual/using_save_system/writing-and-reading.html",
    "title": "Writing and reading data",
    "keywords": "Writing and reading data To write and read data, the save system provides two classes - UnityWriter and UnityReader. They can write and read data respectively. Your MonoBehaviour classes get these data handler from the DataManager when you're saving or loading them. To write and read data you would write: public void Save (UnityWriter writer) { writer.Write(transform.position); writer.Write(transform.rotation); writer.Write(material.color); writer.Write(myClass); writer.Write(myClasses); } public void Load (UnityReader reader) { transform.position = reader.ReadVector3(); transform.rotation = reader.ReadRotation(); material.color = reader.ReadColor(); myClass = reader.ReadObject<MyClass>(); myClasses = reader.ReadArrayObjects<MyClass>(); } Important You must read data in the same order as you write it. If you don't want to worry about this, implement IStorable interface and use SmartHandler. Read this article for more information. To learn how to control custom classes and structs see this part."
  }
}